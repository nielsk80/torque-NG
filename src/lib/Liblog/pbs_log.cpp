/*
*         OpenPBS (Portable Batch System) v2.3 Software License
*
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
*
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
*
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
*
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
*
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
*
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
*
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
*
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
*
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
*
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
*
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
*
* 7. DISCLAIMER OF WARRANTY
*
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
*
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/
/*
 * pbs_log.c - contains functions to log error and event messages to
 * the log file.
 *
 * Functions included are:
 * log_open()
 * log_err()
 * log_ext()
 * log_record()
 * log_close()
 * log_roll()
 * log_size()
 */

#include <pbs_config.h>   /* the master config generated by configure */
#include "pbs_log.h"

#include "portability.h"
#include "pbs_error.h"

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <time.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <dirent.h>
// #include <pthread.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/time.h>

#include "log.h"
#if SYSLOG
#include <syslog.h>
#endif

#include <execinfo.h> /* backtrace information */
#include<arpa/inet.h>
#include<netdb.h>

#include <safe_log.hpp>

#include <mutex>
#include <string>
#include <string_view>
#include <array>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <filesystem>
#include <chrono>
#include <vector>

void job_log_close(int msg);

/* Global Data */
std::string log_buffer;
static std::string log_directory;
static std::string job_log_directory;
static std::string log_host_port;
static std::string log_host;
static std::string log_suffix;

static std::string msg_daemonname = "unset";

/* Local Data */

static int      log_auto_switch = 0;
static int      log_open_day;
static FILE     *logfile;  /* open stream for log file */
static std::string   logpath;
static volatile int  log_opened = 0;
#if SYSLOG
static int      syslogopen = 0;
#endif /* SYSLOG */

std::mutex log_mutex;

/* variables for job logging */
static int      job_log_auto_switch = 0;
static int      joblog_open_day;
static FILE     *joblogfile;  /* open stream for log file */
static std::string   joblogpath;
static volatile int  job_log_opened = 0;

std::mutex job_log_mutex;

/*
 * the order of these names MUST match the defintions of
 * PBS_EVENTCLASS_* in log.h
 */
static constexpr std::array<std::string_view, 10> class_names =
  {
  "n/a",      // 0: PBS_EVENTCLASS_SERVER (or padding)
  "Svr",      // 1: PBS_EVENTCLASS_SERVER
  "Que",      // 2: PBS_EVENTCLASS_QUEUE
  "Job",      // 3: PBS_EVENTCLASS_JOB
  "Req",      // 4: PBS_EVENTCLASS_REQUEST
  "Fil",      // 5: PBS_EVENTCLASS_FILE
  "Act",      // 6: PBS_EVENTCLASS_ACCT
  "node",     // 7: PBS_EVENTCLASS_NODE
  "trqauthd", // 8: PBS_EVENTCLASS_TRQAUTHD
  "mom"       // 9: PBS_EVENTCLASS_MOM
  };

/* External functions called */

/* local prototypes */
static std::string_view log_get_severity_string(int severity);


namespace fs = std::filesystem;

/*
 * mk_log_name - make the log name used by MOM
 * based on the date: yyyymmdd
 */

 std::string mk_log_name()
  {
  struct tm tmpPtm = {}; 
  time_t    time_now = time(nullptr);
  
  // Get local time safely
  localtime_r(&time_now, &tmpPtm);

  // Use a stringstream for efficient path building
  std::ostringstream oss;
  
  // Format the directory and the date (YYYYMMDD)
  oss << log_directory << "/" 
      << std::setfill('0') << std::setw(4) << (tmpPtm.tm_year + 1900)
      << std::setfill('0') << std::setw(2) << (tmpPtm.tm_mon + 1)
      << std::setfill('0') << std::setw(2) << tmpPtm.tm_mday;

  // Handle the suffix logic
  if (!log_suffix.empty())
    {
    oss << ".";
    if (log_suffix == "%h")
      {
      oss << (!log_host.empty() ? log_host : "localhost");
      }
    else
      {
      oss << log_suffix;
      }
    }

  // Update the Julian date global (keep this inside the lock if called from log_open)
  log_open_day = tmpPtm.tm_yday;

  return oss.str();
  }




/*
 * mk_job_log_name - make the log name used by MOM
 * based on the date: yyyymmdd
 */

static char *mk_job_log_name(

  char *pbuf,
  int   buf_size)

  {
  struct tm *ptm;
  struct tm  tmpPtm;
  time_t time_now = time(nullptr);

  if (pbuf == nullptr || buf_size <= 0) return pbuf;

  ptm = localtime_r(&time_now,&tmpPtm);

  if (ptm == nullptr)
    {
    return pbuf;
    }

  std::ostringstream oss;

  oss << job_log_directory << "/" 
      << std::setfill('0') << std::setw(4) << (ptm->tm_year + 1900)
      << std::setfill('0') << std::setw(2) << (ptm->tm_mon + 1)
      << std::setfill('0') << std::setw(2) << ptm->tm_mday;

  if (!log_suffix.empty())
    {
      std::string suffix_to_use = log_suffix;
      if (log_suffix == "%h")
      {
        suffix_to_use = (!log_host.empty() ? log_host.c_str() : "localhost");
      }
      oss << "." << suffix_to_use;
    }

  // 3. Final Copy: Convert stream to string and safely copy to buffer
    std::string result = oss.str();
    size_t copy_len = std::min(static_cast<size_t>(buf_size - 1), result.length());
    
    memcpy(pbuf, result.c_str(), copy_len);
    pbuf[copy_len] = '\0'; // Hard null-termination

  joblog_open_day = ptm->tm_yday; /* Julian date log opened */

  return(pbuf);
  }  /* END mk_job_log_name() */




int log_init(

  std::string_view suffix,    /* I (optional) */
  std::string_view hostname)  /* I (optional) */

  {
  if (!suffix.empty())
    log_suffix = suffix;

  if (!hostname.empty() )
    log_host = hostname;

  return(PBSE_NONE);
  }  /* END log_init() */



int log_open(

  std::string_view filename,  /* abs filename or nullptr */
  std::string_view directory) /* normal log directory */

  {
  std::lock_guard<std::mutex> lock(log_mutex);
  return log_open_unlocked(filename, directory);
  }  /* END log_open() */

/*
 * log_open_unlocked() - open the log file for append.
 *
 * Opens a (new) log file.
 * If a log file is already open, and the new file is successfully opened,
 * the old file is closed.  Otherwise the old file is left open.
 */

int log_open_unlocked(

  std::string_view filename,  /* abs filename or nullptr */
  std::string_view directory) /* normal log directory */

  {
  std::string  buf;
  std::string  buf2;
  int   fds;

  if (log_opened > 0)
    {
    return(-1); /* already open */
    }

  if (log_directory != directory)  /* some calls pass in log_directory */
    {
    log_directory = directory;
    }

  if (filename.empty())
    {
    filename = mk_log_name();

    log_auto_switch = 1;
    }
  else if (filename.front() != '/')
    {
    return(-1); /* must be absolute path */
    }

  if ((fds = open(filename.data(), O_CREAT | O_WRONLY | O_APPEND, 0644)) < 0)
    {
    log_opened = -1; /* note that open failed */

    return(-1);
    }

  if (fds < 3)
    {
    log_opened = fcntl(fds, F_DUPFD, 3); /* overload variable */

    if (log_opened < 0)
      {
      close(fds);
      return(-1);
      }

    close(fds);

    fds = log_opened;
    }

  /* save the path of the last opened logfile for log_roll */
  if (logpath != filename)
    {
      logpath = filename;
    }

  logfile = fdopen(fds, "a");

  if (logfile == nullptr)
    {
    log_opened = -1;
    return(-1);
    }

  setvbuf(logfile, nullptr, _IOLBF, 0); /* set line buffering */

  log_opened = 1;   /* note that file is open */

  if (!log_host_port.empty())
    buf2 = "Log opened at " + log_host_port;
  else
    buf2 = "Log opened";


  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "Log",
    buf2.c_str());

  return(0);
  }  /* END log_open_unlocked() */



/*
 * job_log_open() - open the log file for append.
 *
 * Opens a (new) log file.
 * If a log file is already open, and the new file is successfully opened,
 * the old file is closed.  Otherwise the old file is left open.
 */

int job_log_open(

  std::string_view filename,  /* abs filename or nullptr */
  std::string_view directory) /* normal log directory */

  {
  char  buf[_POSIX_PATH_MAX];
  std::ostringstream err_log;
  int   fds;

  if (job_log_opened > 0)
    {
    return(1); /* already open */
    }

  if (job_log_directory != directory)  /* some calls pass in job_log_directory */
    {
    job_log_directory = directory;
    }

  if (filename.empty())
    {
    filename = mk_job_log_name(buf, _POSIX_PATH_MAX);

    job_log_auto_switch = 1;
    }
  else if (filename.front() != '/')
    {
    err_log << "must use absolute file path: " << filename;
    log_err(-1, __func__, err_log.str().c_str());
    return(-1); /* must be absolute path */
    }

  if ((fds = open(filename.data(), O_CREAT | O_WRONLY | O_APPEND, 0644)) < 0)
    {
    job_log_opened = -1; /* note that open failed */

    std::ostringstream err_log;
    err_log << "could not open " << filename;
    log_err(errno, __func__, err_log.str().c_str());
    return(-1);
    }

  if (fds < 3)
    {
    job_log_opened = fcntl(fds, F_DUPFD, 3); /* overload variable */

    if (job_log_opened < 0)
      {
      close(fds);
      log_err(errno, __func__, "failed to dup job log file descriptor");
      return(-1);
      }

    close(fds);

    fds = job_log_opened;
    }

  /* save the path of the last opened joblogfile for log_roll */
  if (joblogpath != filename)
    {
    if (!joblogpath.empty())
      joblogpath.clear();

    joblogpath = filename;
    }

  joblogfile = fdopen(fds, "a");

  setvbuf(joblogfile, nullptr, _IOLBF, 0); /* set line buffering */

  job_log_opened = 1;   /* note that file is open */

  return(0);
  }  /* END job_log_open() */


// Helper to format the error string (replaces EPtr logic)
static std::string format_error_code(int errnum) {
    if (errnum == -1) return "";

    const char* err_txt = (errnum >= 15000) ? pbse_to_txt(errnum) : strerror(errnum);
    
    std::ostringstream oss;
    if (err_txt) {
        oss << err_txt << " (" << errnum << ") in ";
    } else {
        oss << "unexpected error " << errnum << " in ";
    }
    return oss.str();
}

/*
 * log_err - log an internal error
 * The error is recorded to the pbs log file and to syslogd if it is
 * available.  If the error file has not been opened and if syslog is
 * not defined, then the console is opened.
 */

void log_err(
  int         errnum,  /* I (errno or PBSErrno) */
  std::string_view routine, /* I */
  std::string_view text)    /* I */

  {
    log_ext(errnum,routine,text,LOG_ERR);

    return;
  }  /* END log_err() */




/*
 *  log_ext (log extended) - log message to syslog (if available) and to the TORQUE log.
 *
 *  The error is recorded to the TORQUE log file and to syslogd if it is
 *  available.  If the error file has not been opened and if syslog is
 *  not defined, then the console is opened.

 *  Note that this function differs from log_err in that you can specify a severity
 *  level that will accompany the message in the syslog (see 'manpage syslog' for a list
 *  of severity/priority levels). This function, is in fact, used by log_err--it just uses
 *  a severity level of LOG_ERR
 */

 void log_ext(int errnum, std::string_view routine, std::string_view text, int severity) {
    // String views work seamlessly with ostringstream
    std::ostringstream msg_stream;
    
    msg_stream << log_get_severity_string(severity) << "::"
               << format_error_code(errnum)
               << (routine.empty() ? "unknown" : routine) << ", "
               << (text.empty() ? "" : text);

    std::string full_msg = msg_stream.str();

    // Safe access using our g_job_log object
    auto log = g_job_log.access();

    // Fallback logic
    if (!log.is_open) {
#if !SYSLOG
        g_job_log.open("/dev/console");
#endif
    }

    // Console output
    if (isatty(2)) {
        fprintf(stderr, "%s: %s\n", msg_daemonname.c_str(), full_msg.c_str());
    }

    // Torque Log Record
    if (log.is_open) {
        // Passing full_msg.c_str() because the record function 
        // likely still expects a C-string for legacy reasons.
        log_record_unlocked(PBSEVENT_ERROR | PBSEVENT_FORCE, 
                            PBS_EVENTCLASS_SERVER, 
                            msg_daemonname, 
                            full_msg.c_str());
    }

#if SYSLOG
    if (syslogopen == 0) {
        openlog(msg_daemonname, LOG_NOWAIT, LOG_DAEMON);
        syslogopen = 1;
    }
    syslog(severity | LOG_DAEMON, "%s", full_msg.c_str());
#endif
}

/**
 * Returns a string to represent the syslog severity-level given.
 */

static std::string_view log_get_severity_string(int severity)
  {

  /* We can't just index into an array to get the strings, as we don't always
   * have control over what the value of the LOG_* consts are */

  switch (severity)
    {
    case LOG_EMERG:   return "LOG_EMERGENCY";
    case LOG_ALERT:   return "LOG_ALERT";
    case LOG_CRIT:    return "LOG_CRITICAL";
    case LOG_ERR:     return "LOG_ERROR";
    case LOG_WARNING: return "LOG_WARNING";
    case LOG_NOTICE:  return "LOG_NOTICE";
    case LOG_DEBUG:   return "LOG_DEBUG";
    default:          return "LOG_INFO";
    }
  }  /* END log_get_severity_string() */


/* record job information of completed job to job log */
int log_job_record(std::string_view buf)
  {
  struct tm *ptm;
  struct tm tmpPtm;
  time_t now;

  now = time((time_t *)0);
  ptm = localtime_r(&now,&tmpPtm);

  std::lock_guard<std::mutex> lock(job_log_mutex);

  /* do we need to switch the log to the new day? */
  if (job_log_auto_switch && (ptm->tm_yday != joblog_open_day))
    {
    job_log_close(1);

    job_log_open("", job_log_directory);

    if (job_log_opened < 1)
      {
      log_err(-1, __func__, "job_log_opened < 1");
      return(-1);
      }
    }

  fprintf(joblogfile, "%s\n", buf.data());
  fflush(joblogfile);

  return(0);
  }

/*
 * See if the log is open. In client commands this will return false.
 */

bool log_available()
  {
#if SYSLOG
  if(eventtype&PBSEVENT_SYSLOG)
    return true;
#endif
  if(log_opened < 1)
    return true;
  return false;
  }

/*
 * log_record - This is a wrapper that locks the log_mutex
 * and then call log_record_unlocked to log a message to the log file
 * The log file must have been opened by log_open().
 * 
 * NOTE:  do not use in pbs_mom spawned children - does not write to syslog!!!
 *
 * The caller should ensure proper formating of the message if "text"
 * is to contain "continuation lines".
 */

void log_record(
  int              eventtype,
  int              eventclass,
  std::string_view objname,
  std::string_view text) {

  // This simple wrapper uses our new Accessor logic
  auto log = g_job_log.access();
  
  if (log.is_open) {
    log_record_unlocked(eventtype, eventclass, objname, text);
  }
}

/*
 * log_record_unlocked - log a message to the log file
 * The log file must have been opened by log_open().
 * It is assumed the calling function has already obtained the log_mutex lock.
 *
 * NOTE:  do not use in pbs_mom spawned children - does not write to syslog!!!
 *
 * The caller should ensure proper formating of the message if "text"
 * is to contain "continuation lines".
 */

void log_record_unlocked(
  int              eventtype,
  int              eventclass,
  std::string_view objname,
  std::string_view text) {

  // Access the raw file handle from our SafeLog structure
  // Note: Since this is 'unlocked', we expect a FILE* to be passed 
  // or a global state to be used. 
  
  auto log = g_job_log.access(); // If we haven't refactored the caller yet

  if (log.is_open) {
      // Modern C++: Write directly to the file stream or use fprintf
      // string_view doesn't have .c_str(), so we use .data() and .size() 
      // or simply rely on stream-style formatting.
      
      fprintf(log.file, "Event %d Class %d: [%.*s] %.*s\n",
              eventtype,
              eventclass,
              static_cast<int>(objname.size()), objname.data(),
              static_cast<int>(text.size()), text.data());
      
      fflush(log.file);
  }
} /* END log_record_unlocked() */


/*
 * log_close - close the current open log file
 */

void log_close(

  int msg)  /* BOOLEAN - write close message */

  {
  std::string buf;
  if (log_opened == 1)
    {
    log_auto_switch = 0;

    if (msg)
      {
      if (log_host_port[0])
        buf = "Log closed at " + log_host_port;
      else
        buf = "Log closed";

      log_record(
        PBSEVENT_SYSTEM,
        PBS_EVENTCLASS_SERVER,
        "Log",
        buf.c_str());
      }

    fclose(logfile);

    log_opened = 0;
    }


  return;
  }  /* END log_close() */

/*
 * job_log_close - close the current open job log file
 */

void job_log_close(

  int msg)  /* BOOLEAN - write close message */

  {
  if (job_log_opened == 1)
    {
    job_log_auto_switch = 0;

    if (msg)
      {
      log_record(
        PBSEVENT_SYSTEM,
        PBS_EVENTCLASS_SERVER,
        "Log",
        "Log closed");
      }

    fclose(joblogfile);

    job_log_opened = 0;
    }

#if SYSLOG

  if (syslogopen)
    closelog();

#endif /* SYSLOG */

  return;
  }  /* END job_log_close() */




/**
 * log_remove_old - Removes log files older than a given time.
 * This function removes files from the given path if they were last modified after ExpireTime.
 *
 * Note that this function will skip over special filenames like '.' and '..'.
 *
 * @param DirPath (I)
 * @param ExpireTime (I, how old the file must be to be removed, in seconds)
 * if (Expiretime == 0), nothing will be removed
 * @return 0 on success, non-zero otherwise
 */


int log_remove_old(std::string_view DirPath, unsigned long ExpireTime) {
  // 1. Guard clauses
  if (DirPath.empty()) return -1;
  if (ExpireTime == 0) return 0;

  try {
    fs::path dir_path(DirPath);

    if (!fs::exists(dir_path) || !fs::is_directory(dir_path)) {
      return -1;
    }

    auto now = std::chrono::system_clock::now();
    
    // 2. Use directory_iterator (Modern opendir/readdir replacement)
    for (const auto& entry : fs::directory_iterator(dir_path)) {
      // Skips "." and ".." automatically
      
      try {
        // Skip directories - we only want to remove log files
        if (!entry.is_regular_file()) continue;

        // 3. Get file modification time
        // last_write_time is more efficient than calling stat manually
        auto ftime = fs::last_write_time(entry);
        
        // Convert file_time_type to system_clock for comparison
        auto s_ftime = std::chrono::time_point_cast<std::chrono::system_clock::duration>(
            ftime - fs::file_time_type::clock::now() + std::chrono::system_clock::now());
        
        auto file_age = std::chrono::duration_cast<std::chrono::seconds>(now - s_ftime).count();

        // 4. Check expiration
        if (static_cast<unsigned long>(file_age) > ExpireTime) {
          std::string path_str = entry.path().string();
          
          // Format log message safely with std::string
          std::string log_msg = "Removing log " + path_str + 
                                " - log age = " + std::to_string(file_age) + 
                                ", Expire time = " + std::to_string(ExpireTime);
          
          // Use your modernized log_err (which accepts std::string_view)
          log_err(-1, __func__, log_msg);

          // 5. Secure removal
          fs::remove(entry.path());
        }
      } catch (const fs::filesystem_error& e) {
        // Log individual file error but continue processing others
        continue; 
      }
    }
  } catch (const fs::filesystem_error& e) {
    // Log directory access error
    log_err(errno, __func__, e.what());
    return -1;
  }

  return 0;
}

void log_roll(int max_depth) {
  int err = 0;

  // 1. Lock protection
  std::lock_guard<std::mutex> lock(log_mutex);

  if (!log_opened) {
    return;
  }

  /* save value of log_auto_switch */
  int auto_switch = log_auto_switch;

  // Close the current log through our shared logic
  log_close(1);

  try {
    // logpath should be a std::string or compatible type in your global state
    fs::path base_path(logpath);

    // 2. Remove the oldest log file (logpath.max_depth)
    // We use base_path.string() + suffix because pbs_log usually 
    // expects a dot-extension for rotation.
    fs::path oldest_log = base_path.string() + "." + std::to_string(max_depth);
    
    std::error_code ec;
    if (!fs::remove(oldest_log, ec) && ec && ec != std::errc::no_such_file_or_directory) {
      err = ec.value();
    } else {
      // 3. Roll the rest of the log files (max_depth-1 down to 0)
      for (int i = max_depth - 1; i >= 0; --i) {
        fs::path source;
        if (i == 0) {
          source = base_path;
        } else {
          source = base_path.string() + "." + std::to_string(i);
        }

        fs::path dest = base_path.string() + "." + std::to_string(i + 1);

        // rename file if it exists
        fs::rename(source, dest, ec);
        
        if (ec && ec != std::errc::no_such_file_or_directory) {
          err = ec.value();
          break; // Exit loop on actual filesystem error
        }
        ec.clear(); // Reset error code for next iteration
      }
    }
  } catch (const fs::filesystem_error& e) {
    err = e.code().value();
  }

  // 4. Re-open log using modernized signature
  // Passing "" instead of nullptr to satisfy -Wnonnull and our string_view logic
  if (auto_switch) {
    log_open_unlocked("", log_directory);
  } else {
    log_open_unlocked(logpath, log_directory);
  }

  // 5. Reporting
  if (err != 0) {
    log_err(err, __func__, "error while rolling logs");
  } else {
    log_record(
      PBSEVENT_SYSTEM,
      PBS_EVENTCLASS_SERVER,
      "Log",
      "Log Rolled");
  }
}


void job_log_roll(int max_depth) {
  int err = 0;
  std::string source;
  std::string dest;

  std::lock_guard<std::mutex> lock(job_log_mutex);

  if (!job_log_opened)
    return;

  /* save value of job_log_auto_switch */
  int as = job_log_auto_switch;

  job_log_close(1);

  // 1. Prepare 'dest' for the initial unlink of the oldest log
  // std::to_string() replaces the manual suffix_size calculations
  dest = std::string(joblogpath) + "." + std::to_string(max_depth);

  if ((unlink(dest.c_str()) != 0) && (errno != ENOENT)) {
    err = errno;
  } else {
    // 2. Roll the rest of the log files
    for (int i = max_depth - 1; i >= 0; i--) {
      if (i == 0) {
        source = joblogpath;
      } else {
        source = std::string(joblogpath) + "." + std::to_string(i);
      }

      dest = std::string(joblogpath) + "." + std::to_string(i + 1);

      /* rename file if it exists */
      if ((rename(source.c_str(), dest.c_str()) != 0) && (errno != ENOENT)) {
        err = errno;
        break; // Replaces 'goto' - exits the loop on actual error
      }
    }
  }

  // 3. Re-open log
  if (as) {
    job_log_open("", job_log_directory);
  } else {
    job_log_open(joblogpath, job_log_directory);
  }

  // 4. Reporting
  if (err != 0) {
    log_err(err, "log_roll", "error while rolling logs");
  } else {
    log_record(
      PBSEVENT_SYSTEM, 
      PBS_EVENTCLASS_SERVER, 
      "Job Log", 
      "Job Log Rolled");
  }
}


/* return size of log file in kilobytes */

long log_size(void)

  {
#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64) && defined(LARGEFILE_WORKS)

  struct stat64 file_stat = {0};
#else

  struct stat file_stat;
#endif

  std::lock_guard<std::mutex> lock(log_mutex);

#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64) && defined(LARGEFILE_WORKS)

  if (log_opened && (fstat64(fileno(logfile), &file_stat) != 0))
#else
  if (log_opened && (fstat(fileno(logfile), &file_stat) != 0))
#endif
    {
    /* FAILURE */

    /* log_err through log_ext will lock the log_mutex, so release log_mutex before calling log_err */
    log_err(errno, "log_size", "PBS cannot fstat logfile");

    return(0);
    }

  if (!log_opened) {
      log_err(EAGAIN, "log_size", "PBS cannot find size of log file because logfile has not been opened");
      return(0);
  }


  return(file_stat.st_size / 1024);
  }

/* return size of job log file in kilobytes */

long job_log_size(void)

  {
#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64) && defined(LARGEFILE_WORKS)

  struct stat64 file_stat;
#else

  struct stat file_stat;
#endif

  memset(&file_stat, 0, sizeof(file_stat));
  std::lock_guard<std::mutex> lock(job_log_mutex);

#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64) && defined(LARGEFILE_WORKS)

  if (job_log_opened && (fstat64(fileno(joblogfile), &file_stat) != 0))
#else
  if (job_log_opened && (fstat(fileno(joblogfile), &file_stat) != 0))
#endif
    {
    /* FAILURE */

    log_err(errno, __func__, "PBS cannot fstat joblogfile");

    return(0);
    }

  return(file_stat.st_size / 1024);
  }


void print_trace(

  int socknum)

  {
  void  *array[10];
  int    size;
  char **meth_names;
  int    cntr;
  char   msg[120];
  char   meth_name[20];

  size = backtrace(array, 10);
  meth_names = backtrace_symbols(array, size);
  snprintf(meth_name, sizeof(meth_name), "pt - pos %d", socknum);
  snprintf(msg, sizeof(msg), "Obtained %d stack frames.\n", size);
  log_record(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER, meth_name, msg);
  for (cntr = 0; cntr < size; cntr++)
    {
    log_record(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER, meth_name, meth_names[cntr]);
    }
  free(meth_names);
  }


void log_get_set_eventclass(

  int *objclass,
  SGetter action)

  {
  static int log_objclass = 0;

  if (action == SETV)
    log_objclass = *objclass;
  else if (action == GETV)
    *objclass = log_objclass;

  } /* end of log_get_set_evnetclass */

void log_format_trq_timestamp(

  char *time_formatted_str,
  unsigned int buflen)

  {
  char           buffer[30];
  struct timeval tv;
  time_t         curtime;
  struct tm      result;
  unsigned int   milisec=0;

  gettimeofday(&tv, nullptr);
  curtime=tv.tv_sec;

  localtime_r(&curtime, &result);
  strftime(buffer,30,"%Y-%m-%d %H:%M:%S.", &result);
  milisec = tv.tv_usec/100;
  snprintf(time_formatted_str, buflen, "%s%04d", buffer, milisec);
  } /* end of log_format_trq_timestamp */

/// @brief 
/// @param server_name 
/// @param server_port 

void log_set_hostname_sharelogging(std::string_view server_name, std::string_view server_port)
 {
  std::string ip = "unknown";
  std::string final_hostname;
  char hostnm[1024];

  // 1. Determine the hostname to resolve
  if (!server_name.empty())
    {
    final_hostname = server_name;
    }
  else if (gethostname(hostnm, sizeof(hostnm)) == 0)
    {
    final_hostname = hostnm;
    }
  else
    {
    final_hostname = "unknown";
    }

  // 2. Thread-safe DNS Resolution using getaddrinfo
  if (final_hostname != "unknown")
    {
    struct addrinfo hints = {}, *res = nullptr;
    hints.ai_family = AF_INET; // Force IPv4 to match original inet_ntoa logic

    if (getaddrinfo(final_hostname.c_str(), nullptr, &hints, &res) == 0 && res != nullptr)
      {
      struct sockaddr_in *ipv4 = (struct sockaddr_in *)res->ai_addr;
      char ip_buf[INET_ADDRSTRLEN];
      
      if (inet_ntop(AF_INET, &(ipv4->sin_addr), ip_buf, sizeof(ip_buf)))
        ip = ip_buf;

      freeaddrinfo(res); // Clean up the linked list
      }
    }

    // 3. Format the result into your modernized global string
    // Use a lock_guard because we are modifying a global string
    {
    std::lock_guard<std::mutex> lock(log_mutex);
  
    std::ostringstream oss;
    oss << ip << ":" << (server_port.empty() ? "0" : server_port) 
        << " (host: " << final_hostname << ")";
  
    log_host_port = oss.str();
    }
 } 

/* END pbs_log.c */
